\documentclass{sig-alternate}
\usepackage{url}
\usepackage{tabulary}

\begin{document}
%
% --- Author Metadata here ---
\conferenceinfo{OzCHI}{'15, December 07-10, 2015, Melbourne, Australia}
%\CopyrightYear{2015} % Allows default copyright year (20XX) to be over-ridden - IF NEED BE.
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% --- End of Author Metadata ---

\title{Comparing usability of concurrency models}

\numberofauthors{1}
\author{
\alignauthor
Ben Swift, Peter Davis, Henry Gardner\\
\vskip .3em
\affaddr{Research School of Computer Science}\\
\affaddr{Australian National University}\\
\affaddr{Canberra, Australia}\\
\vskip .3em
\email{\{ben.swift,peter.davis,henry.gardner\}@anu.edu.au}
}

\maketitle

\begin{abstract}
Abstract goes here.
\end{abstract}

\section{ Concurrency}
This paper explores concurrency with the aim of describing concurrent programming from a HCI viewpoint. The field of concurrent processing is notable for having mutliple applications, architectures and problems that sequential programming paradigms do not have. This exploration is interesting as the primary constraint in the development of quality (as defined by \cite{9126}) concurrent systems is the inability of the programmer to develop using the prevalent concrrent tools.

We start by introducing a conceptual model similar to the Open Systems Interconnect (OSI) Model but intended for use in understanding concurency concepts. We make the argument that all implemented concurrent solutions utilise these concurrency concepts, whether or not they are explicitly or implicitly mentioned.

We then introduce 'Cognitive Dimensions', an established (by  \cite{green89:_cognit_dimen_notat}) and broad framework for evaluating cognitive systems in general, and relate some concurrent concepts in terms of the cognitive dimensions framework.

Lastly we introduce four commonly used models of concurrency: Threads, Bulk Synchronous Parallel (BSP), Communicating Sequential Processes (CSP) and Message Passing Interface (MPI), and describe these in terms of both the concurrency framework and the CD framework, making some preliminary observations about their ease of use.

\subsection{Concurrency Definitions}
There exists some confusion around definiton of concurrent systems, with some users mistaking concurrency for paralellism \cite{pike13:_concur_paral}, and others seeing asynchronous function calls as differenct concurrency

Concurrency refers to systems where there is more than one process existing at a time, whose component processes interact with each other by communication \cite{tpc}.
There exists a 

We further make the distinction between distributed and independent systems by whether the executing processes are separated by the presence of a connecting system other than a local memory or cache. Normally a network stack.

There is some debate as to the difference between asynchronous systems and parallel systems, with the former being primarily identified by the existence of non-blocking calls and the latter being identified via independently running processes.

\section{Common Concurrency Issues}
\subsection{General Issues}
\cite{shanlu08:_learn_mistak_compr_study_real} examines the problem patterns, manifestation and solutions of 105 randomly selected real world concurrency bugs. This paper only looked at threading and pointers (as this is the dominant concurrent programming paradigm), but the issues explored are broadly applicable to all concurrent programming models.

\subsubsection{Deadlock}
Defined by \cite{shanlu08:_learn_mistak_compr_study_real} as:``Deadlock occurs when two or more operations circularly wait for each other to release the acquired resource''. Whilst being the most well known 

\subsubsection{Atomicity Violation}
Defined by \cite{shanlu08:_learn_mistak_compr_study_real} as: ``The desired serializability among multiple memory accesses is violated (i.e. a code region is intended to be atomic, but the atomicity is not enforced during execution)''. \cite{shanlu08:_learn_mistak_compr_study_real} found that out of 105 studied concurrency bugs, 

\subsubsection{Order Violation}
Defined by \cite{shanlu08:_learn_mistak_compr_study_real} as:``The desired order between two (groups of) memory accesses is flipped (i.e., A should always be executed before B, but the order is not enforced during execution)''. This is also known as a race condition. 

\subsubsection{Livelock}
Defined by \cite{oracle:_starv_livel} as when: ``Threads are not blocked - they are simply too busy responding to one another to continue work''. This issue was not identified specifically by \cite{shanlu08:_learn_mistak_compr_study_real} and so its real world prevalence is unclear.

\subsection{Distributed Issues}
The issues that distributed concurrent systems face include all of the singular system problems, but are affected by the vagaries of both a more complicated underying physical interconnection sysstem and a greater number of individual components potentially affected by failure. The eight fallacies of distributed computing are a widely used overview of the problems affecting distributed systems:

\begin{enumerate}
\item The network is reliable
\item Latency is zero
\item Bandwidth is infinite
\item The network is secure
\item Topology doesn't change
\item There is one administrator
\item The transport cost is zero
\item The network is homogenous
\end{enumerate}

\subsubsection{Coherence}

\subsubsection{Reliability}

\subsection{Concurrency layers}
Introduce 'axes', with which concurrency models will be evaluated.

Similar to the OSI model of splitting the network stack by each layer, each layer relies on the previous layer in order to function properly and provide services to the next layer up.

\begin{tabulary}{\linewidth}{LLLLL}
 & Layer & Example \\ \hline
1 & Physical &  Physical computing hardware, network connnections \\
2 & Communication & MPI, ZeroMQ, Pointers \\
3 & Concurrency  & BSP, Actor, CSP, Threads \\
4 & Algorithmic Skeleton & Farm, pipe, map, reduce, divide and conquer\\
5 & Solution Algorithm & FFT, MapReduce, Particle-In-Cell (PIC)
\end{tabulary}

\section{Usability in a Programming Context}
Usability is typically considered as a metric of software quality, and is defined by \cite{9126} as: ``The capability of the software product to be understood, learned, used and attractive to the user, when used under specified conditions.'' However, this definition is aimed at end users encountering finished softaare products, rather than being aimed at the programmer who is engaged in making th software.

Programmers face a separate set of usability issues when writing software. Usability issues can ariise from the Computer Assisted Engineering Tools (CASE), from the usage of a third party library, or from a particular softare architectural pattern. The last item is of particualr interest when working with concurrenct and sitributed system, as these software patterns are notorious for being hard to reason about and hence have ppor usability.

In order to explore the usability of various concurrency models we borrow the Cognitive Dimensions \cite{green89:_cognit_dimen_notat} (CD) framework, which was initially developed to explore the productivity of visual programming environments but has been used more broadly in areas such as programming language evaluation \cite{enpl}, and 

\section{Concurrency Models}
\subsection{Threads}


\subsection{BSP}
Original paper advocated distributed memory using hashing
Modern implementations such as Pregel and Apache Giraph use a messaging system.
Supersteps within which it is assumed that no synchronisation is required
End of superstep a global synchronisation step

\subsection{Actor}
Independent workers
Messaging system, mailboxes
Erlang

\subsection{CSP}
Go channels and clojures core.async

\subsection{}

\section{Comparing Models}

\subsection{Hidden Dependencies}

Recovering the mental representation from the concurrent program is difficult, as there is not necessarily any sequential manner in which the program may operate. As such, for each process in a concurrent system there are hidden dependencies in the form of the other processes in the system, which may be in any number of states and producing any number of communications to the process being considered.

\subsection{Viscosity/Fluidity}
The viscoisity of a concurrent program is hard to generalize. On one hand, the program may be very fluid, as if it is a operation that is replicated is performed across many nodes with little or no variance in each nodes funciton, then the program is very fluid as any changes made only need to be made to a single part of the code, and this code will be replicated to all processes.

However, if the concurrent program  has manny different nodes with different behaviours and functions then it may be a viscous procedure to any part of the program, as the flow on effects from that change will need to be tracked and accounted for in the downstream or dependent nodes.

\subsection{Premature commitment}
Concurrent programs encourage some degree of premature commitment from the programmer, particularly along the concurrecy layers. Before being able to attack the root of the probelm they are trying to solve, the programmer will need to take into account the concurrency model, the skeleton algorithm and the communication method. Whether the problem is being solved via a workflow style DAG topology or will determine the structure of the concurrency model, considerations such as whether messages between processes can be buffered or must be synchronous will affect how they can write the solution.

\subsection{Role Expressiveness}
Role expressiveness is related to how easily the user can discern the purpose of a particular component, and hence create a mental model of how the system works.. Concurrent systems do not offer any particular advantage or disadvantage in this regard; they may provide simpler methods of expressiveness by having each process perform a single easily identifiable role, allowing the user to identify the system purpose as a simple workflow. More complicdated concurrent systems where each process handles multiple functions within the system may cause the programmer difficulty in identify the role of particular system components. 

Increasing the role expressivenesss of a concurrent system can be thought of as decreasing the number of functions that a particular process is required to complete, thereby allowing the programmer to easily identify the role of each process and its place within the overall system. This may come a cost of less performant system, greater hardware requirements to support the greater number of simpler concurrency nodes, or may be completely impossible if the solution demands. 

\subsection{Hard Mental Operations}
Not all mental operations are equivalent, and concurrent programmings non-sequential execution model is a ripe ground for misunderstanding. stuff goes here

\section{Conclusion}


% \begin{figure}
% \centering
% \epsfig{file=fly.eps, height=1in, width=1in}
% \caption{A sample black and white graphic (.eps format)
% that has been resized with the \texttt{epsfig} command.}
% \end{figure}

\bibliographystyle{abbrv}
\bibliography{distributed-computing-ozchi-2015}
\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

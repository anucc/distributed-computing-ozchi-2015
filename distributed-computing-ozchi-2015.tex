% This is "sig-alternate.tex" V1.9 April 2009
% This file should be compiled with V2.4 of "sig-alternate.cls" April 2009
%
% This example file demonstrates the use of the 'sig-alternate.cls'
% V2.4 LaTeX2e document class file. It is for those submitting
% articles to ACM Conference Proceedings WHO DO NOT WISH TO
% STRICTLY ADHERE TO THE SIGS (PUBS-BOARD-ENDORSED) STYLE.
% The 'sig-alternate.cls' file will produce a similar-looking,
% albeit, 'tighter' paper resulting in, invariably, fewer pages.
%
% ----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V2.4) produces:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) NO page numbers
%
% as against the acm_proc_article-sp.cls file which
% DOES NOT produce 1) thru' 3) above.
%
% Using 'sig-alternate.cls' you have control, however, from within
% the source .tex file, over both the CopyrightYear
% (defaulted to 200X) and the ACM Copyright Data
% (defaulted to X-XXXXX-XX-X/XX/XX).
% e.g.
% \CopyrightYear{2007} will cause 2007 to appear in the copyright line.
% \crdata{0-12345-67-8/90/12} will cause 0-12345-67-8/90/12 to appear in the copyright line.
%
% ---------------------------------------------------------------------------------------------------------------
% This .tex source is an example which *does* use
% the .bib file (from which the .bbl file % is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission, you *NEED* to 'insert'
% your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% ================= IF YOU HAVE QUESTIONS =======================
% Questions regarding the SIGS styles, SIGS policies and
% procedures, Conferences etc. should be sent to
% Adrienne Griscti (griscti@acm.org)
%
% Technical questions _only_ to
% Gerald Murray (murray@hq.acm.org)
% ===============================================================
%
% For tracking purposes - this is V1.9 - April 2009

\documentclass{sig-alternate}

\begin{document}
%
% --- Author Metadata here ---
\conferenceinfo{OzCHI}{'15, December 07-10, 2015, Melbourne, Australia}
%\CopyrightYear{2015} % Allows default copyright year (20XX) to be over-ridden - IF NEED BE.
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% --- End of Author Metadata ---

\title{Comparing usability of concurrency models}

\numberofauthors{1}
\author{
\alignauthor
Ben Swift, Peter Davis, Henry Gardner\\
\vskip .3em
\affaddr{Research School of Computer Science}\\
\affaddr{Australian National University}\\
\affaddr{Canberra, Australia}\\
\vskip .3em
\email{\{ben.swift,peter.davis,henry.gardner\}@anu.edu.au}
}

\maketitle

\begin{abstract}
Abstract goes here.
\end{abstract}

\section{Introduction to Concurrency}
Concurrency refers to systems where there is more than one process existing at a time, whose component processes interact with each other by communication \cite{tpc} . It does not say anything about the processes executing at the same time, and concurrent systems on single processor machines are an example of this.

Asynchronous definition

Parallel definition

Distributed definition

\subsection{Concurrency Problems}
Deadlock


Livelock


Race Conditions
Where the outcome of the program is non-deterministic due to incorrect assumptions made about the sequence of completed actions.

Thrashing
Moving quickly between execution states or processes, so as to spend more time communicating changes between the various running processes than spending computational time within a process.

\subsection{Concurrency layers}
Introduce 'axes', with which concurrency models will be evaluated.

Similar to the OSI model of splitting the network stack by each layer, each layer relies on the previous layer in order to function properly and provide services to the next layer up.

\begin{table}[]
\centering
\caption{My caption}
\label{my-label}
\begin{tabular}{llll}
 & Layer & Description & Example \\ \hline
1 & Physical & Layer responsible for items such as: location, power, cooling, physical connections between machines & Physical computing hardware, network connnections \\
2 & Communication & Layer responsible for allowing any processes to communicate in a common fashion & MPI, ZeroMQ, Pointers \\
3 & Concurrency & Layer responsible for organising concurrent execution of code. & BSP, Actor, CSP, Threads \\
4 & Algorithmic Skeleton/Topology & Layer responsible for organising and directing the interconnections between concurrent processes. This may correspond to the physical layout of the machines. & Farm, pipe, map, divide and conquer\\
5 & Solution Algorithm & Layer responsible for providing a solution to the problem being tasked. & FFT, MapReduce, simulations
\end{tabular}
\end{table}

\section{Usability in a Programming Context}
Usability is typically considered as a metric of software quality, and is defined by \cite{9126} as: ``The capability of the software product to be understood, learned, used and attractive to the user, when used under specified conditions.'' However, this definition is aimed at end users encountering finished softaare products, rather than being aimed at the programmer who is engaged in making th software.

Programmers face a separate set of usability issues when writing software. Usability issues can ariise from the Computer Assisted Engineering Tools (CASE), from the usage of a third party library, or from a particular softare architectural pattern. The last item is of particualr interest when working with concurrenct and sitributed system, as these software patterns are notorious for being hard to reason about and hence have ppor usability.

In order to explore the usability of various concurrency models we borrow the Cognitive Dimensions \cite{green89:_cognit_dimen_notat} (CD) framework, which was initially developed to explore the productivity of visual programming environments but has been used more broadly in areas such as programming language evaluation \cite{enpl}, and 



\section{Concurrency Models}
\subsection{Threads}


\subsection{BSP}
Original paper advocated distributed memory using hashing
Modern implementations such as Pregel and Apache Giraph use a messaging system.
Supersteps within which it is assumed that no synchronisation is required
End of superstep a global synchronisation step

\subsection{Actor}
Independent workers
Messaging system, mailboxes

\subsection{CSP}
Go channels and clojures core.async

\subsection{}

\section{Comparing Models}

Hidden Dependencies
Recovering the mental representation from the concurrent program is difficult, as there is not necessarily any sequential manner in which the program may operate. As such, for each process in a concurrent system there are hidden dependencies in the form of the other processes in the system, which may be in any number of states and producing any number of communications to the process being considered.

Viscosity/Fluidity
The viscoisity of a concurrent program is hard to generalize. On one hand, the program may be very fluid, as if it is a operation that is replicated is performed across many nodes with little or no variance in each nodes funciton, then the program is very fluid as any changes made only need to be made to a single part of the code, and this code will be replicated to all processes.

However, if the concurrent program  has manny different nodes with different behaviours and functions then it may be a viscous procedure to any part of the program, as the flow on effects from that change will need to be tracked and accounted for in the downstream or dependent nodes.

Premature commitment
Concurrent programs encourage some degree of premature commitment from the programmer, particularly along the concurrecy layers. Before being able to attack the root of the probelm they are trying to solve, the programmer will need to take into account the concurrency model, the skeleton algorithm and the communication method. Whether the problem is being solved via a workflow style DAG topology or will determine the structure of the concurrency model, considerations such as whether messages between processes can be buffered or must be synchronous will affect how they can write the solution.

Role Expressiveness
Role expressiveness is related to how easily the user can discern the purpose of a particular component, and hence create a mental model of how the system works.. Concurrent systems do not offer any particular advantage or disadvantage in this regard; they may provide simpler methods of expressiveness by having each process perform a single easily identifiable role, allowing the user to identify the system purpose as a simple workflow. More complicdated concurrent systems where each process handles multiple functions within the system may cause the programmer difficulty in identify the role of particular system components. 

Increasing the role expressivenesss of a concurrent system can be thought of as decreasing the number of functions that a particular process is required to complete, thereby allowing the programmer to easily identify the role of each process and its place within the overall system. This may come a cost of less performant system, greater hardware requirements to support the greater number of simpler concurrency nodes, or may be completely impossible if the solution demands. 

Hard Mental Operations
Not all mental operations are equivalent, and concurrent programmings non-sequential execution model is a ripe ground for misunderstanding. stuff goes here

\section{Conclusion}


% \begin{figure}
% \centering
% \epsfig{file=fly.eps, height=1in, width=1in}
% \caption{A sample black and white graphic (.eps format)
% that has been resized with the \texttt{epsfig} command.}
% \end{figure}

\bibliographystyle{abbrv}
\bibliography{distributed-computing-ozchi-2015}
\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
